// tests/doubles/openai.mock.js
// Mock OpenAI client for integration tests (Sprint 2)

/**
 * Mock OpenAI client
 * Returns pre-defined responses from fixtures instead of calling real API
 *
 * Usage:
 *   const openai = createMockOpenAI({ defaultResponse: validRuleResponse });
 *   const completion = await openai.chat.completions.create({ ... });
 */

export class MockOpenAICompletions {
  constructor(fixtures, callLog) {
    this.fixtures = fixtures;
    this.callLog = callLog;
  }

  async create(params) {
    this.callLog.push({ method: 'create', params });

    // Find matching fixture based on prompt or use default
    let response = this.fixtures.defaultResponse;

    // If prompt matches a specific fixture key, use that
    if (params.messages && params.messages.length > 0) {
      const userMessage = params.messages.find(m => m.role === 'user');
      if (userMessage && this.fixtures.responsesMap) {
        // Check if instruction matches a fixture key
        for (const [key, fixture] of Object.entries(this.fixtures.responsesMap)) {
          if (userMessage.content.toLowerCase().includes(key.toLowerCase())) {
            response = fixture;
            break;
          }
        }
      }
    }

    // Return response with proper structure
    return {
      id: response.id || `chatcmpl-mock-${Date.now()}`,
      object: 'chat.completion',
      created: Math.floor(Date.now() / 1000),
      model: params.model || 'gpt-4',
      choices: response.choices || [{
        index: 0,
        message: response.message || {
          role: 'assistant',
          content: null,
          function_call: response.function_call
        },
        finish_reason: response.finish_reason || 'function_call'
      }],
      usage: response.usage || {
        prompt_tokens: 450,
        completion_tokens: 120,
        total_tokens: 570
      }
    };
  }
}

export class MockOpenAIChat {
  constructor(fixtures, callLog) {
    this.completions = new MockOpenAICompletions(fixtures, callLog);
  }
}

export class MockOpenAIClient {
  constructor(fixtures = {}) {
    this.fixtures = {
      defaultResponse: fixtures.defaultResponse || this._getDefaultResponse(),
      responsesMap: fixtures.responsesMap || {}
    };
    this.callLog = [];
    this.chat = new MockOpenAIChat(this.fixtures, this.callLog);
  }

  _getDefaultResponse() {
    // Default valid fraud rule response
    return {
      function_call: {
        name: 'generate_fraud_rule',
        arguments: JSON.stringify({
          ruleset_name: 'mock-rule',
          description: 'Mock rule generated by test double',
          decision: 'review',
          conditions: [
            { field: 'amount', op: '>', value: 1000 }
          ]
        })
      },
      finish_reason: 'function_call'
    };
  }

  resetCallLog() {
    this.callLog = [];
  }

  getCallCount() {
    return this.callLog.length;
  }

  getLastCall() {
    return this.callLog[this.callLog.length - 1];
  }
}

/**
 * Create a mock OpenAI client with fixtures
 * @param {Object} options
 * @param {Object} options.defaultResponse - Default response to return
 * @param {Object} options.responsesMap - Map of instruction keywords to responses
 * @returns {MockOpenAIClient}
 */
export function createMockOpenAI({ defaultResponse, responsesMap } = {}) {
  return new MockOpenAIClient({ defaultResponse, responsesMap });
}

/**
 * Common fixture responses for testing
 */
export const MOCK_RESPONSES = {
  VALID_RULE_HIGH_VALUE: {
    function_call: {
      name: 'generate_fraud_rule',
      arguments: JSON.stringify({
        ruleset_name: 'high-value-mobile',
        description: 'Review mobile transactions over $10k outside business hours',
        decision: 'review',
        conditions: [
          { field: 'amount', op: '>', value: 10000 },
          { field: 'device', op: '==', value: 'mobile' },
          { field: 'hour', op: '<', value: 9 }
        ]
      })
    }
  },

  VALID_RULE_FIRST_TXN: {
    function_call: {
      name: 'generate_fraud_rule',
      arguments: JSON.stringify({
        ruleset_name: 'first-transaction-high-value',
        description: 'Block first-time transactions over $50k',
        decision: 'block',
        conditions: [
          { field: 'is_first_transaction', op: '==', value: true },
          { field: 'amount', op: '>', value: 50000 }
        ]
      })
    }
  },

  INVALID_RULE_DISALLOWED_FIELD: {
    function_call: {
      name: 'generate_fraud_rule',
      arguments: JSON.stringify({
        ruleset_name: 'geographic-rule',
        description: 'Block transactions from specific country',
        decision: 'block',
        conditions: [
          { field: 'country_of_origin', op: '==', value: 'XX' }
        ]
      })
    }
  },

  INVALID_RULE_ENUM_VALUE: {
    function_call: {
      name: 'generate_fraud_rule',
      arguments: JSON.stringify({
        ruleset_name: 'desktop-rule',
        description: 'Review desktop transactions',
        decision: 'review',
        conditions: [
          { field: 'device', op: '==', value: 'desktop' }  // Invalid enum
        ]
      })
    }
  }
};

// Sprint 2 TODO:
// - Add support for streaming responses (if needed)
// - Add latency simulation (to test timeout handling)
// - Add error injection (to test error handling)
// - Load fixtures from JSON files
